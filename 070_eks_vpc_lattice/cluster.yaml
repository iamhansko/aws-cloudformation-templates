Transform: AWS::LanguageExtensions
Parameters:
  InboundFromAnywhere:
    Type: String
    Default: "False"
    AllowedValues: ["True", "False"]
    Description: SecurityGroup Inbound Rule (Source 0.0.0.0/0)
  KubernetesVersion:
    Description: EKS Cluster Kubernetes Version (1.XX)
    Type: String
    Default: "1.32"
    AllowedValues: ["1.32"]
  AmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64
Conditions:
  SecurityGroupInboundFromAnywhere: !Equals [!Ref InboundFromAnywhere, "True"]

Mappings:
  AzMapping: 
    a:
      PublicSubnetCidr: 10.0.0.0/24
      PrivateSubnetCidr: 10.0.1.0/24
    b: 
      PublicSubnetCidr: 10.0.2.0/24
      PrivateSubnetCidr: 10.0.3.0/24
    c: 
      PublicSubnetCidr: 10.0.4.0/24
      PrivateSubnetCidr: 10.0.5.0/24

Resources:
  KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Sub
        - key-${Id}
        - Id: !Select [3, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]
  
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: True
      EnableDnsHostnames: True
      Tags:
        - Key: Name
          Value: vpc

  # PublicSubnets
  Fn::ForEach::PublicSubnets:
    - Az
    - [a, c]
    - PublicSubnet${Az}:
        Type: AWS::EC2::Subnet
        Properties:
          AvailabilityZone: !Sub ${AWS::Region}${Az}
          CidrBlock: !FindInMap [AzMapping, !Ref Az, PublicSubnetCidr]
          MapPublicIpOnLaunch: true
          Tags:
            - Key: Name
              Value: !Sub public-subnet-${Az}
          VpcId: !Ref Vpc
      PublicSubnet${Az}RouteTableAssociation:
        Type: AWS::EC2::SubnetRouteTableAssociation
        Properties:
          RouteTableId: !Ref PublicSubnetRouteTable
          SubnetId: 
            Ref: !Sub PublicSubnet${Az}
  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      Tags:
        - Key: Name
          Value: public-rt
      VpcId: !Ref Vpc
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: igw
  VpcInternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref Vpc
  PublicSubnetRoute:
    Type: AWS::EC2::Route
    DependsOn:
      - VpcInternetGatewayAttachment
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
      RouteTableId: !Ref PublicSubnetRouteTable
  
  # PrivateSubnets
  Fn::ForEach::PrivateSubnets:
    - Az
    - [a, c]
    - PrivateSubnet${Az}:
        Type: AWS::EC2::Subnet
        Properties:
          VpcId: !Ref Vpc
          CidrBlock: !FindInMap [AzMapping, !Ref Az, PrivateSubnetCidr]
          AvailabilityZone: !Sub ${AWS::Region}${Az}
          Tags:
            - Key: Name
              Value: !Sub private-subnet-${Az}
      NatgatewayElasticIp${Az}:
        Type: AWS::EC2::EIP
      PrivateSubnet${Az}RouteTableAssociation:
        Type: AWS::EC2::SubnetRouteTableAssociation
        Properties:
          RouteTableId: !Ref PrivateSubnetRouteTable
          SubnetId:
            Ref: !Sub PrivateSubnet${Az}
  PrivateSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: !Ref Vpc
      Tags:
        - Key: Name
          Value: !Sub private-rt
  PrivateSubnetRoute:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      NatGatewayId: !Ref NatGateway
      RouteTableId: !Ref PrivateSubnetRouteTable
  NatGateway:
    Type: AWS::EC2::NatGateway
    DependsOn:
      - VpcInternetGatewayAttachment
    Properties:
      VpcId: !Ref Vpc
      AvailabilityMode: regional
      AvailabilityZoneAddresses:
        - AvailabilityZone: !Sub ${AWS::Region}a
          AllocationIds: 
            - !GetAtt NatgatewayElasticIpa.AllocationId
        - AvailabilityZone: !Sub ${AWS::Region}c
          AllocationIds: 
            - !GetAtt NatgatewayElasticIpc.AllocationId
      Tags: 
        - Key : Name
          Value : !Sub regional-natgw
  
  VsCodeEc2:
    Type: AWS::EC2::Instance
    DependsOn:
      - CoreNodeGroup
    CreationPolicy:
      ResourceSignal:
        Count: '1'                
        Timeout: PT15M
    Properties:
      ImageId: !Ref AmiId
      InstanceType: t3.medium
      KeyName: !Ref KeyPair
      NetworkInterfaces: 
        - AssociatePublicIpAddress: True
          DeviceIndex: 0
          SubnetId: !Ref PublicSubneta
          GroupSet: 
            - !GetAtt EksCluster.ClusterSecurityGroupId
            - !Ref VsCodeEc2SecurityGroup
      Tags: 
        - Key: Name
          Value: vscode
      IamInstanceProfile: !Ref VsCodeEc2InstanceProfile
      UserData: 
        # sudo tail -f /var/log/cloud-init-output.log
        Fn::Base64: !Sub |
          #!/bin/bash
          dnf update -yq
          dnf install -yq git
          dnf groupinstall -yq "Development Tools"

          export VSC_VERSION="4.106.2"
          wget https://github.com/coder/code-server/releases/download/v$VSC_VERSION/code-server-$VSC_VERSION-linux-amd64.tar.gz
          tar -xzf code-server-$VSC_VERSION-linux-amd64.tar.gz
          mv code-server-$VSC_VERSION-linux-amd64 /usr/local/lib/code-server
          ln -s /usr/local/lib/code-server/bin/code-server /usr/local/bin/code-server
          mkdir -p /home/ec2-user/.config/code-server
          cat <<EOF > /home/ec2-user/.config/code-server/config.yaml
          bind-addr: 0.0.0.0:8000
          auth: none
          cert: false
          EOF
          chown -R ec2-user:ec2-user /home/ec2-user/.config
          cat <<EOF > /etc/systemd/system/code-server.service
          [Unit]
          Description=VS Code Server
          After=network.target
          [Service]
          Type=simple
          User=ec2-user
          ExecStart=/usr/local/bin/code-server --config /home/ec2-user/.config/code-server/config.yaml /home/ec2-user
          Restart=always
          [Install]
          WantedBy=multi-user.target
          EOF
          systemctl daemon-reload
          systemctl enable code-server
          systemctl start code-server

          sudo -Eu ec2-user bash << 'EOF'
          cd /home/ec2-user
          mkdir -p /home/ec2-user/bin
          curl -O https://s3.us-west-2.amazonaws.com/amazon-eks/1.33.3/2025-08-03/bin/linux/amd64/kubectl
          chmod +x kubectl
          mv kubectl /home/ec2-user/bin/kubectl
          export PATH=/home/ec2-user/bin:$PATH
          echo "export PATH=/home/ec2-user/bin:$PATH" >> ~/.bashrc
          echo "alias k=kubectl" >> ~/.bashrc
          echo "complete -o default -F __start_kubectl k" >> ~/.bashrc
          echo "source <(kubectl completion bash)" >> ~/.bashrc
          exec bash

          curl --silent --location "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" | tar xz -C /tmp
          sudo mv /tmp/eksctl /usr/local/bin

          curl -fsSL -o /home/ec2-user/get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-4
          chmod 700 /home/ec2-user/get_helm.sh
          /home/ec2-user/get_helm.sh
          rm /home/ec2-user/get_helm.sh

          aws eks update-kubeconfig --region ${AWS::Region} --name ${EksCluster} --alias nvidia
          helm repo add eks https://aws.github.io/eks-charts
          helm repo update eks
          helm install aws-load-balancer-controller eks/aws-load-balancer-controller -n kube-system --wait \
          --set clusterName=${EksCluster} \
          --set serviceAccount.name=aws-load-balancer-controller \
          --set region=${AWS::Region} \
          --set vpcId=${Vpc}
          sleep 60

          mkdir -p /home/ec2-user/manifests
          echo 'apiVersion: storage.k8s.io/v1
          kind: StorageClass
          metadata:
            name: gp3
            annotations:
              storageclass.kubernetes.io/is-default-class: "true"
          parameters:
            type: gp3
          provisioner: ebs.csi.aws.com
          reclaimPolicy: Delete
          volumeBindingMode: WaitForFirstConsumer' > manifests/ebs_storageclass.yaml
          kubectl apply -f manifests/ebs_storageclass.yaml
          sleep 10

          export AWS_REGION=${AWS::Region}
          export AWS_ACCOUNT_ID=${AWS::AccountId}
          export EKS_CLUSTER_NAME=${EksCluster}
          export EKS_CLUSTER_VPC=${Vpc}
          kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/standard-install.yaml
          aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws
          helm upgrade --install gateway-api-controller oci://public.ecr.aws/aws-application-networking-k8s/aws-gateway-controller-chart \
          --version=v1.1.5 \
          --namespace aws-application-networking-system --create-namespace \
          --set awsRegion=$AWS_REGION \
          --set awsAccountId=$AWS_ACCOUNT_ID \
          --set clusterName=$EKS_CLUSTER_NAME \
          --set clusterVpcId=$EKS_CLUSTER_VPC \
          --set webhookEnabled=false \
          --set=defaultServiceNetwork=eks-network \
          --wait

          echo '# EKS + VPC Lattice
          
          ## AWS Gateway API Controller Installation
          ```
          export AWS_REGION=${AWS::Region}
          export AWS_ACCOUNT_ID=${AWS::AccountId}
          export EKS_CLUSTER_NAME=${EksCluster}
          export EKS_CLUSTER_VPC=${Vpc}
          kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/standard-install.yaml
          aws ecr-public get-login-password --region us-east-1 | helm registry login --username AWS --password-stdin public.ecr.aws
          helm upgrade --install gateway-api-controller oci://public.ecr.aws/aws-application-networking-k8s/aws-gateway-controller-chart \
          --version=v1.1.5 \
          --namespace aws-application-networking-system --create-namespace \
          --set awsRegion=$AWS_REGION \
          --set awsAccountId=$AWS_ACCOUNT_ID \
          --set clusterName=$EKS_CLUSTER_NAME \
          --set clusterVpcId=$EKS_CLUSTER_VPC \
          --set webhookEnabled=false \
          --set=defaultServiceNetwork=eks-network \
          --wait
          ```

          ## Create VPC Lattice ServiceNetwork(Gateway) & Services(HttpRoutes)
          kubectl apply -f /home/ec2-user/manifests/vpc_lattice.yaml

          ## VPC Lattice Test
          export ratesFQDN=$(kubectl get httproute rates -o json | jq -r ".metadata.annotations.\"application-networking.k8s.aws/lattice-assigned-domain-name\"")
          export inventoryFQDN=$(kubectl get httproute inventory -o json | jq -r ".metadata.annotations.\"application-networking.k8s.aws/lattice-assigned-domain-name\"")
          echo -e "$ratesFQDN \n$inventoryFQDN"
          kubectl exec deploy/inventory-ver1 -- curl -s $ratesFQDN/parking $ratesFQDN/review $inventoryFQDN
          kubectl exec deploy/parking -- curl -s $ratesFQDN/parking $ratesFQDN/review $inventoryFQDN

          ' > /home/ec2-user/README.md

          echo 'apiVersion: gateway.networking.k8s.io/v1beta1
          kind: GatewayClass
          metadata:
            name: amazon-vpc-lattice
          spec:
            controllerName: application-networking.k8s.aws/gateway-api-controller
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: Gateway
          metadata:
            name: eks-network
          spec:
            gatewayClassName: amazon-vpc-lattice
            listeners:
            - name: http
              protocol: HTTP
              port: 80
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: parking
            labels:
              app: parking
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: parking
            template:
              metadata:
                labels:
                  app: parking
              spec:
                containers:
                - name: parking
                  image: public.ecr.aws/x2j8p8w7/http-server:latest
                  env:
                  - name: PodName
                    value: "parking handler pod"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: parking
          spec:
            selector:
              app: parking
            ports:
              - protocol: TCP
                port: 80
                targetPort: 8090
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: review
            labels:
              app: review
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: review
            template:
              metadata:
                labels:
                  app: review
              spec:
                containers:
                - name: aug24-review
                  image: public.ecr.aws/x2j8p8w7/http-server:latest
                  env:
                  - name: PodName
                    value: "review handler pod"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: review
          spec:
            selector:
              app: review
            ports:
              - protocol: TCP
                port: 80
                targetPort: 8090
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: rates
          spec:
            parentRefs:
            - name: eks-network
              sectionName: http
            rules:
            - backendRefs:
              - name: parking
                kind: Service
                port: 80
              matches:
              - path:
                  type: PathPrefix
                  value: /parking
            - backendRefs:
              - name: review
                kind: Service
                port: 80
              matches:
              - path:
                  type: PathPrefix
                  value: /review
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: inventory-ver1
            labels:
              app: inventory-ver1
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: inventory-ver1
            template:
              metadata:
                labels:
                  app: inventory-ver1
              spec:
                containers:
                - name: inventory-ver1
                  image: public.ecr.aws/x2j8p8w7/http-server:latest
                  env:
                  - name: PodName
                    value: "Inventory-ver1 handler pod"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: inventory-ver1
          spec:
            selector:
              app: inventory-ver1
            ports:
              - protocol: TCP
                port: 80
                targetPort: 8090
          ---
          apiVersion: gateway.networking.k8s.io/v1
          kind: HTTPRoute
          metadata:
            name: inventory
          spec:
            parentRefs:
            - name: eks-network
              sectionName: http
            rules:
            - backendRefs:
              - name: inventory-ver1
                kind: Service
                port: 80
                weight: 10
          ---
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: inventory-ver2
            labels:
              app: inventory-ver2
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: inventory-ver2
            template:
              metadata:
                labels:
                  app: inventory-ver2
              spec:
                containers:
                - name: inventory-ver2
                  image: public.ecr.aws/x2j8p8w7/http-server:latest
                  env:
                  - name: PodName
                    value: "Inventory-ver2 handler pod"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: inventory-ver2
          spec:
            selector:
              app: inventory-ver2
            ports:
              - protocol: TCP
                port: 80
                targetPort: 8090' > /home/ec2-user/manifests/vpc_lattice.yaml
          kubectl apply -f /home/ec2-user/manifests/vpc_lattice.yaml

          EOF

          /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource VsCodeEc2 --region ${AWS::Region}
  VsCodeEc2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group
      GroupName: vscode-sg
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        !If [SecurityGroupInboundFromAnywhere, [{
          "IpProtocol": "tcp",
          "FromPort": 8000,
          "ToPort": 8000,
          "CidrIp": "0.0.0.0/0"
        }], []]
      Tags:
        - Key: Name
          Value: vscode-sg
  VsCodeEc2IamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
  VsCodeEc2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: 
        - !Ref VsCodeEc2IamRole

  EksCluster:
    Type: AWS::EKS::Cluster
    Properties:
      Version: !Ref KubernetesVersion
      AccessConfig: 
        AuthenticationMode: API_AND_CONFIG_MAP
        BootstrapClusterCreatorAdminPermissions: true
      BootstrapSelfManagedAddons: false
      Logging: 
        ClusterLogging: 
          EnabledTypes: 
            - Type: api
            - Type: audit
            - Type: authenticator
            - Type: controllerManager
            - Type: scheduler
      ResourcesVpcConfig: 
        EndpointPrivateAccess: true
        EndpointPublicAccess: true
        SubnetIds: 
          - !Ref PublicSubneta
          - !Ref PublicSubnetc
          - !Ref PrivateSubneta
          - !Ref PrivateSubnetc
      RoleArn: !GetAtt EksClusterIamRole.Arn
      KubernetesNetworkConfig:
        IpFamily: ipv4
        ServiceIpv4Cidr: 172.20.0.0/16
  EksClusterIamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - eks.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSClusterPolicy
  EksOidcProvider:
    Type: AWS::IAM::OIDCProvider
    Properties:
      Url: !GetAtt EksCluster.OpenIdConnectIssuerUrl
      ClientIdList: 
        - sts.amazonaws.com
  VpcCniAddOn:
    Type: AWS::EKS::Addon
    Properties:
      AddonName: vpc-cni
      ClusterName: !Ref EksCluster
      ResolveConflicts: OVERWRITE
      ConfigurationValues: |
        env:
          ENABLE_MULTI_NIC: "true"
  KubeProxyAddOn:
    Type: AWS::EKS::Addon
    Properties:
      AddonName: kube-proxy
      ClusterName: !Ref EksCluster
      ResolveConflicts: OVERWRITE
  CoreDnsAddOn:
    Type: AWS::EKS::Addon
    Properties:
      AddonName: coredns
      ClusterName: !Ref EksCluster
      ResolveConflicts: OVERWRITE
  PodIdentityAgentAddon:
    Type: AWS::EKS::Addon
    Properties:
      AddonName: eks-pod-identity-agent
      ClusterName: !Ref EksCluster
      ResolveConflicts: OVERWRITE
  EbsCsiDriverAddon:
    Type: AWS::EKS::Addon
    Properties:
      AddonName: aws-ebs-csi-driver
      ClusterName: !Ref EksCluster
      PodIdentityAssociations:
        - RoleArn: !GetAtt EbsCsiDriverRole.Arn
          ServiceAccount: ebs-csi-controller-sa
  CoreNodeGroup:
    Type: AWS::EKS::Nodegroup
    Properties:
      NodegroupName: core-nodegroup
      AmiType: AL2023_x86_64_STANDARD
      InstanceTypes:
        # https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-eni.html#network-cards
        - t3.large
      CapacityType: ON_DEMAND
      ClusterName: !Ref EksCluster
      ForceUpdateEnabled: true
      NodeRole: !GetAtt EksNodeIamRole.Arn
      ScalingConfig: 
        DesiredSize: 1
        MaxSize: 3
        MinSize: 1
      Subnets: 
        - !Ref PrivateSubneta
        - !Ref PrivateSubnetc
  EksNodeIamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEKSWorkerNodePolicy
        - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly
        - arn:aws:iam::aws:policy/AmazonEKS_CNI_Policy
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
  AwsLoadBalancerControllerRole:
    # https://raw.githubusercontent.com/kubernetes-sigs/aws-load-balancer-controller/refs/heads/main/docs/install/iam_policy.json
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: pods.eks.amazonaws.com
            Action:
              - sts:AssumeRole
              - sts:TagSession
      Policies:
        - PolicyName: AWSLoadBalancerControllerPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - iam:CreateServiceLinkedRole
                Resource: "*"
                Condition:
                  StringEquals: 
                    iam:AWSServiceName: elasticloadbalancing.amazonaws.com
              - Effect: Allow
                Action: 
                  - ec2:*
                  - elasticloadbalancing:*
                Resource: "*"
              - Effect: Allow
                Action: 
                  - cognito-idp:DescribeUserPoolClient
                  - acm:ListCertificates
                  - acm:DescribeCertificate
                  - iam:ListServerCertificates
                  - iam:GetServerCertificate
                  - waf-regional:GetWebACL
                  - waf-regional:GetWebACLForResource
                  - waf-regional:AssociateWebACL
                  - waf-regional:DisassociateWebACL
                  - wafv2:GetWebACL
                  - wafv2:GetWebACLForResource
                  - wafv2:AssociateWebACL
                  - wafv2:DisassociateWebACL
                  - shield:GetSubscriptionState
                  - shield:DescribeProtection
                  - shield:CreateProtection
                  - shield:DeleteProtection
                Resource: "*"
  AwsLoadBalancerControllerRolePodIdentityAssociation:
    Type: AWS::EKS::PodIdentityAssociation
    Properties:
      ClusterName: !Ref EksCluster
      Namespace: kube-system
      RoleArn: !GetAtt AwsLoadBalancerControllerRole.Arn
      ServiceAccount: aws-load-balancer-controller
  EbsCsiDriverRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: pods.eks.amazonaws.com
            Action:
              - sts:AssumeRole
              - sts:TagSession
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy
  GatewayApiControllerRole:
    # https://raw.githubusercontent.com/aws/aws-application-networking-k8s/main/files/controller-installation/recommended-inline-policy.json
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: pods.eks.amazonaws.com
            Action:
              - sts:AssumeRole
              - sts:TagSession
      Policies:
        - PolicyName: GatewayApiControllerPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - vpc-lattice:*
                  - ec2:DescribeVpcs
                  - ec2:DescribeSubnets
                  - ec2:DescribeTags
                  - ec2:DescribeSecurityGroups
                  - logs:CreateLogDelivery
                  - logs:GetLogDelivery
                  - logs:DescribeLogGroups
                  - logs:PutResourcePolicy
                  - logs:DescribeResourcePolicies
                  - logs:UpdateLogDelivery
                  - logs:DeleteLogDelivery
                  - logs:ListLogDeliveries
                  - tag:GetResources
                  - firehose:TagDeliveryStream
                  - s3:GetBucketPolicy
                  - s3:PutBucketPolicy
                  - tag:TagResources
                  - tag:UntagResources
                Resource: "*"
              - Effect: Allow
                Action: iam:CreateServiceLinkedRole
                Resource: arn:aws:iam::*:role/aws-service-role/vpc-lattice.amazonaws.com/AWSServiceRoleForVpcLattice
                Condition:
                  StringLike:
                    iam:AWSServiceName: vpc-lattice.amazonaws.com
              - Effect: Allow
                Action: iam:CreateServiceLinkedRole
                Resource: arn:aws:iam::*:role/aws-service-role/delivery.logs.amazonaws.com/AWSServiceRoleForLogDelivery
                Condition:
                  StringLike:
                    iam:AWSServiceName: delivery.logs.amazonaws.com
  GatewayApiControllerRolePodIdentityAssociation:
    Type: AWS::EKS::PodIdentityAssociation
    Properties:
      ClusterName: !Ref EksCluster
      Namespace: aws-application-networking-system
      RoleArn: !GetAtt GatewayApiControllerRole.Arn
      ServiceAccount: gateway-api-controller
  VsCodeEc2IamAccessEntry:
    Type: AWS::EKS::AccessEntry
    Properties:
      AccessPolicies: 
        - AccessScope: 
            Type: cluster
          PolicyArn: arn:aws:eks::aws:cluster-access-policy/AmazonEKSClusterAdminPolicy
      ClusterName: !Ref EksCluster
      PrincipalArn: !GetAtt VsCodeEc2IamRole.Arn
      Type: STANDARD
  
  EksClusterSecurityGroupVpcLatticeIngress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: -1
      GroupId: !GetAtt EksCluster.ClusterSecurityGroupId
      SourcePrefixListId: !GetAtt VpcLatticePrefixList.PrefixListId
  EksClusterSecurityGroupVpcLatticeIpv6Ingress:
    Type: AWS::EC2::SecurityGroupIngress
    Properties:
      IpProtocol: -1
      GroupId: !GetAtt EksCluster.ClusterSecurityGroupId
      SourcePrefixListId: !GetAtt VpcLatticeIpv6PrefixList.PrefixListId
  VpcLatticePrefixList:
    Type: Custom::ManagedPrefixList
    Properties:
      ServiceToken: !GetAtt CustomLambdaFunction.Arn
      PrefixListName: !Sub com.amazonaws.${AWS::Region}.vpc-lattice
  VpcLatticeIpv6PrefixList:
    Type: Custom::ManagedPrefixList
    Properties:
      ServiceToken: !GetAtt CustomLambdaFunction.Arn
      PrefixListName: !Sub com.amazonaws.${AWS::Region}.ipv6.vpc-lattice
  CustomLambdaFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.lambda_handler
      Role: !GetAtt CustomLambdaIamRole.Arn
      Timeout: 30
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          
          def lambda_handler(event, context):
            print(json.dumps(event))            
            try:
              if event["RequestType"] == "Delete":
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                return
              ec2 = boto3.client("ec2")
              prefix_list_name = event["ResourceProperties"]["PrefixListName"]
              prefix_list_data = ec2.describe_managed_prefix_lists(Filters=[{"Name":"prefix-list-name","Values":[prefix_list_name]}])
              prefix_list_id = prefix_list_data["PrefixLists"][0]["PrefixListId"]
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {"PrefixListId": prefix_list_id})
            except Exception as error:
              print(f"Error: {str(e)}")
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason=str(error))
  CustomLambdaIamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: LambdaFunctionPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - ec2:DescribeManagedPrefixLists
                Resource: "*"

Outputs:
  VsCode:
    Value: !Sub http://${VsCodeEc2.PublicIp}:8000
    Description: Public IP Address of the VS Code