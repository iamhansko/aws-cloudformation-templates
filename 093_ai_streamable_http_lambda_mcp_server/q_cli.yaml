AWSTemplateFormatVersion: "2010-09-09"
Description: "CloudFormation Template"
Transform: AWS::Serverless-2016-10-31

Parameters:
  AmiId:
    Type: "AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>"
    Default: "/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-6.1-x86_64"
  McpAuthToken:
    Type: String
    Default: "Peccy"

Mappings:
  ResourceMap:
    Vpc:
      Name : vpc
      CidrBlock: 10.1.0.0/16
    PublicSubnet:
      Name: public
    InternetGateway:
      Name: igw
    BastionEc2:
      Name: bastion
      InstanceType: t3.medium
  # https://aws.amazon.com/ko/blogs/korea/limit-access-to-your-origins-using-the-aws-managed-prefix-list-for-amazon-cloudfront
  # aws ec2 describe-managed-prefix-lists --region <REGION> | jq -r '.PrefixLists[] | select (.PrefixListName == "com.amazonaws.global.cloudfront.origin-facing") | .PrefixListId'
  AWSRegions2PrefixListID:
    ap-northeast-1:
      PrefixList: pl-58a04531
    ap-northeast-2:
      PrefixList: pl-22a6434b
    ap-northeast-3:
      PrefixList: pl-31a14458
    ap-south-1:
      PrefixList: pl-9aa247f3
    ap-southeast-1:
      PrefixList: pl-31a34658
    ap-southeast-2:
      PrefixList: pl-b8a742d1
    ca-central-1:
      PrefixList: pl-38a64351
    eu-central-1:
      PrefixList: pl-a3a144ca
    eu-north-1:
      PrefixList: pl-fab65393
    eu-west-1:
      PrefixList: pl-4fa04526
    eu-west-2:
      PrefixList: pl-93a247fa
    eu-west-3:
      PrefixList: pl-75b1541c
    sa-east-1:
      PrefixList: pl-5da64334
    us-east-1:
      PrefixList: pl-3b927c52
    us-east-2:
      PrefixList: pl-b6a144df
    us-west-1:
      PrefixList: pl-4ea04527
    us-west-2:
      PrefixList: pl-82a045eb

Resources:
  KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Sub
        - "key-${Id}"
        - Id: !Select [3, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: !FindInMap [ResourceMap, Vpc, CidrBlock]
      EnableDnsSupport: True
      EnableDnsHostnames: True
      Tags: 
        - Key : Name
          Value : !FindInMap [ResourceMap, Vpc, Name]
  PublicSubnetA:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: !Sub "${AWS::Region}a"
      CidrBlock: !Select [0, !Cidr [ !GetAtt Vpc.CidrBlock, 4, 8 ]]
      Tags: 
        - Key : Name
          Value : !Join ["-", [!FindInMap [ResourceMap, PublicSubnet, Name], "a"]]
      VpcId: !Ref Vpc
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
      - Key: Name
        Value: !FindInMap [ResourceMap, InternetGateway, Name]
  VpcInternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref Vpc
  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      Tags: 
        - Key : Name
          Value : !Join ["-", [!FindInMap [ResourceMap, PublicSubnet, Name], "rt"]]
      VpcId: !Ref Vpc
  PublicSubnetARouteTableAssociation:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: !Ref PublicSubnetRouteTable
      SubnetId: !Ref PublicSubnetA
  PublicSubnetRoute:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
      RouteTableId: !Ref PublicSubnetRouteTable
  BastionEc2:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Count: '1'                
        Timeout: PT7M
    Properties:
      ImageId: !Ref AmiId
      InstanceType: !FindInMap [ResourceMap, BastionEc2, InstanceType]
      KeyName: !Ref KeyPair
      NetworkInterfaces: 
        - AssociatePublicIpAddress: True
          DeviceIndex: 0
          SubnetId: !Ref PublicSubnetA
          GroupSet: 
            - !Ref BastionEc2SecurityGroup
      Tags: 
        - Key: Name
          Value: !FindInMap [ResourceMap, BastionEc2, Name]
      IamInstanceProfile: !Ref BastionEc2InstanceProfile
      UserData:
        # sudo tail -f /var/log/cloud-init-output.log
        Fn::Base64:
            !Sub |
              #!/bin/bash
              dnf update -yq
              dnf groupinstall -yq "Development Tools"
              dnf install -yq git
              dnf install -yq docker
              systemctl enable --now docker
              # usermod -aG docker ec2-user
              # newgrp docker
              chmod 666 /var/run/docker.sock

              export VSC_VERSION="4.102.3"
              wget -q https://github.com/coder/code-server/releases/download/v$VSC_VERSION/code-server-$VSC_VERSION-linux-amd64.tar.gz
              tar -xzf code-server-$VSC_VERSION-linux-amd64.tar.gz
              mv code-server-$VSC_VERSION-linux-amd64 /usr/local/lib/code-server
              ln -s /usr/local/lib/code-server/bin/code-server /usr/local/bin/code-server

              mkdir -p /home/ec2-user/.config/code-server
              cat <<EOF > /home/ec2-user/.config/code-server/config.yaml
              bind-addr: 0.0.0.0:8000
              auth: none
              cert: false
              EOF
              chown -R ec2-user:ec2-user /home/ec2-user/.config
              cat <<EOF > /etc/systemd/system/code-server.service
              [Unit]
              Description=VS Code Server
              After=network.target
              [Service]
              Type=simple
              User=ec2-user
              ExecStart=/usr/local/bin/code-server --config /home/ec2-user/.config/code-server/config.yaml /home/ec2-user
              Restart=always
              [Install]
              WantedBy=multi-user.target
              EOF
              systemctl daemon-reload
              systemctl enable code-server
              systemctl start code-server

              /opt/aws/bin/cfn-signal -e $? --stack ${AWS::StackName} --resource BastionEc2 --region ${AWS::Region}
  BastionEc2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Security Group for Bastion EC2 SSH Connection"
      GroupName: bastion-sg
      SecurityGroupIngress:
        - Description: com.amazonaws.global.cloudfront.origin-facing
          IpProtocol: tcp
          FromPort: 8000
          ToPort: 8000
          SourcePrefixListId: !FindInMap
            - AWSRegions2PrefixListID
            - !Ref AWS::Region
            - PrefixList
      VpcId: !Ref Vpc
  BastionEc2IamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/PowerUserAccess
      RoleName: Ec2PowerUserRole
  BastionEc2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      InstanceProfileName: Ec2PowerUserProfile
      Roles: 
        - !Ref BastionEc2IamRole
  
  # https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/distribution-working-with.websockets.html
  # https://github.com/aws-samples/code-server-setup-with-cloudformation/blob/main/code-server-stack.yaml
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !GetAtt BastionEc2.PublicDnsName
            Id: !GetAtt BastionEc2.PublicDnsName
            CustomOriginConfig:
              HTTPPort: 8000
              OriginProtocolPolicy: http-only
        Enabled: true
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
            - PUT
            - POST
            - PATCH
            - DELETE
          ForwardedValues:
            QueryString: 'false'
          Compress: false
          TargetOriginId: !GetAtt BastionEc2.PublicDnsName
          ViewerProtocolPolicy: allow-all
          CachePolicyId: !Ref CloudFrontCachePolicy
          OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3 # AllViewer
  CloudFrontCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 1
        Name: !Join
          - '-'
          - - VSCode
            - !Select
              - 4
              - !Split
                - '-'
                - !Select
                  - 2
                  - !Split 
                    - /
                    - !Ref AWS::StackId
        ParametersInCacheKeyAndForwardedToOrigin:
          CookiesConfig:
            CookieBehavior: all
          EnableAcceptEncodingGzip: false
          HeadersConfig:
            HeaderBehavior: whitelist
            Headers:
              - Accept-Charset
              - Authorization
              - Origin
              - Accept
              - Referer
              - Host
              - Accept-Language
              - Accept-Encoding
              - Accept-Datetime
          QueryStringsConfig:
            QueryStringBehavior: all
  
  McpApi:
    Type: AWS::Serverless::Api
    Properties:
      StageName: Prod
      Auth:
        Authorizers:
          TokenAuthorizer:
            FunctionArn: !GetAtt McpAuthorizerFunction.Arn
            FunctionPayloadType: TOKEN
            Identity:
              ReauthorizeEvery: 300
              Header: Authorization
  McpAuthorizerFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.13
      Timeout: 60
      InlineCode: !Sub |
        import os
        import json

        def lambda_handler(event, context):
            """Lambda authorizer for API Gateway."""
            
            # Get the Authorization header from the event
            auth_header = event.get('authorizationToken', '')
            method_arn = event['methodArn']
            
            # Check if it's a Bearer token
            if not auth_header.startswith('Bearer '):
                raise Exception('Unauthorized')  # Return 401 if no valid Authorization header
                
            # Extract and validate token
            token = auth_header.split(' ')[1]
            expected_token = os.environ.get('MCP_AUTH_TOKEN')
            
            if not expected_token or token != expected_token:
                raise Exception('Unauthorized')
                
            # Generate the IAM policy
            return {
                'principalId': 'user',
                'policyDocument': {
                    'Version': '2012-10-17',
                    'Statement': [{
                        'Action': 'execute-api:Invoke',
                        'Effect': 'Allow',
                        'Resource': method_arn
                    }]
                }
            } 
      Environment:
        Variables:
          MCP_AUTH_TOKEN: !Ref McpAuthToken
      Policies:
        - Version: '2012-10-17'
          Statement:
            - Effect: Allow
              Action: 'lambda:InvokeFunction'
              Resource: '*'
  McpSessionsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    Properties:
      TableName: !Sub "${AWS::StackName}-mcp-sessions"
      AttributeDefinitions:
        - AttributeName: session_id
          AttributeType: S
      KeySchema:
        - AttributeName: session_id
          KeyType: HASH
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: expires_at
        Enabled: true
      Tags:
        - Key: Purpose
          Value: MCP Session Management
  McpServerFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: index.lambda_handler
      Runtime: python3.13
      Timeout: 60
      InlineCode: !Sub |
        from awslabs.mcp_lambda_handler import MCPLambdaHandler
        from datetime import datetime, UTC
        import random
        import boto3
        import os

        # Get session table name from environment variable
        session_table = os.environ.get('MCP_SESSION_TABLE', 'mcp_sessions')

        # Create the MCP server instance
        mcp_server = MCPLambdaHandler(name="mcp-lambda-server", version="1.0.0", session_store=session_table)

        @mcp_server.tool()
        def get_weather(city: str) -> str:
            """Get the current weather for a city.
            
            Args:
                city: Name of the city to get weather for
                
            Returns:
                A string describing the weather
            """
            temp = random.randint(15, 35)
            return f"The temperature in {city} is {temp}°C"

        @mcp_server.tool()
        def count_s3_buckets() -> int:
            """Count the number of S3 buckets."""
            s3 = boto3.client('s3')
            response = s3.list_buckets()
            return len(response['Buckets'])

        @mcp_server.tool()
        def get_time() -> str:
            """Get the current UTC date and time, and show how long since last time was asked for (if session available)."""
            try:
                # Get the current UTC time as a datetime object and formatted string
                now = datetime.now(UTC)
                now_str = now.strftime("%Y-%m-%d %H:%M:%S")

                # Retrieve the session object if available
                session = mcp_server.get_session()
                # Get the last time the user asked for the time from the session (if any)
                last_time = session.get('last_time_asked') if session else None
                last_time_str = last_time if last_time else None
                seconds_since = None

                # If there was a previous time, calculate how many seconds have passed
                if last_time:
                    try:
                        last_time_dt = datetime.strptime(last_time, "%Y-%m-%d %H:%M:%S")
                        seconds_since = int((now - last_time_dt).total_seconds())
                    except Exception:
                        # If parsing fails, just skip the seconds_since calculation
                        seconds_since = None

                # Store the current time as the new 'last_time_asked' in the session
                if session:
                    def update_last_time(s):
                        s.set('last_time_asked', now_str)
                    mcp_server.update_session(update_last_time)

                # Build the response string
                response = f"Current UTC time: {now_str}"
                if last_time_str:
                    response += f"\nLast time asked: {last_time_str}"
                    if seconds_since is not None:
                        response += f"\nSeconds since last time: {seconds_since}"
                return response
            
            except Exception as e:
                # Catch-all for unexpected errors
                return f"Error: An unexpected error occurred: {str(e)}"

        def lambda_handler(event, context):
            """AWS Lambda handler function."""
            return mcp_server.handle_request(event, context) 
      Environment:
        Variables:
          MCP_SESSION_TABLE: !Ref McpSessionsTable
      Layers:
        - !GetAtt LambdaLayer.LayerVersionArn
      Policies:
        - Statement:
            - Effect: Allow
              Action:
                - s3:ListBuckets
                - s3:ListAllMyBuckets
              Resource: '*'
            - Effect: Allow
              Action:
                - dynamodb:CreateTable
                - dynamodb:DeleteItem
                - dynamodb:GetItem
                - dynamodb:PutItem
                - dynamodb:UpdateItem
                - dynamodb:DescribeTable
              Resource: !GetAtt McpSessionsTable.Arn
      Events:
        McpAPI:
          Type: Api
          Properties:
            Path: /mcp
            Method: ANY
            RestApiId: !Ref McpApi
            Auth:
              Authorizer: TokenAuthorizer
  
  LambdaLayerSourceBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
  LambdaLayerSsmAssociation:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-RunShellScript
      WaitForSuccessTimeoutSeconds: 180
      Targets:
        - Key: InstanceIds
          Values:
            - !Ref BastionEc2
      Parameters:
        commands: 
          # uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:unconfined_service_t:s0
          - !Sub |
              dnf install -yq python3.13
              ln -sf /usr/bin/python3.13 /usr/bin/python
              python -m ensurepip --upgrade
              wget -qO- https://astral.sh/uv/install.sh | sh
              su - ec2-user << 'EOF'
              cd /home/ec2-user
              mkdir -p ./layer/python
              python -m pip install --platform=manylinux2014_x86_64 --only-binary=:all: awslabs.mcp_lambda_handler -t ./layer/python
              cd /home/ec2-user/layer
              zip -r layer.zip ./python/
              aws s3 cp layer.zip s3://${LambdaLayerSourceBucket}
              rm layer.zip
              EOF
  LambdaLayer:
    Type: AWS::Lambda::LayerVersion
    DependsOn:
      - LambdaLayerSsmAssociation
    Properties:
      CompatibleArchitectures: 
        - x86_64
        - arm64
      CompatibleRuntimes: 
        - python3.13
        - python3.12
        - python3.11
      Content: 
        S3Bucket: !Ref LambdaLayerSourceBucket
        S3Key: layer.zip
  
  QDeveloperSsmAssociation:
    Type: AWS::SSM::Association
    Properties:
      Name: AWS-RunShellScript
      WaitForSuccessTimeoutSeconds: 180
      Targets:
        - Key: InstanceIds
          Values:
            - !Ref BastionEc2
      Parameters:
        commands: 
          # uid=0(root) gid=0(root) groups=0(root) context=system_u:system_r:unconfined_service_t:s0
          - !Sub |
              su - ec2-user <<'EOF'
              export HOME=/home/ec2-user/
              cd $HOME
              # code-server --install-extension amazonwebservices.amazon-q-vscode
              wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash
              export NVM_DIR="$([ -z "${!XDG_CONFIG_HOME-}" ] && printf %s "${!HOME}/.nvm" || printf %s "${!XDG_CONFIG_HOME}/nvm")"
              [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
              nvm install --lts
              curl -s --proto '=https' --tlsv1.2 -sSf "https://desktop-release.q.us-east-1.amazonaws.com/latest/q-x86_64-linux.zip" -o "q.zip"
              unzip q.zip
              ./q/install.sh --no-confirm
              mkdir -p /home/ec2-user/.aws/amazonq
              echo '{
                "mcpServers": {
                  "awslabs.aws-documentation-mcp-server": {
                    "command": "uvx",
                    "args": ["awslabs.aws-documentation-mcp-server@latest"],
                    "env": {
                      "FASTMCP_LOG_LEVEL": "ERROR",
                      "AWS_DOCUMENTATION_PARTITION": "aws"
                    },
                    "disabled": false,
                    "autoApprove": []
                  },
                  "streamable-http-mcp-server": {
                    "command": "npx",
                    "args": [
                      "mcp-remote",
                      "https://${McpApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/mcp",
                      "--header",
                      "Authorization: Bearer ${McpAuthToken}"
                    ]
                  }
                }
              }' > /home/ec2-user/.aws/amazonq/mcp.json
              EOF

Outputs:
  MCPServerApi:
    Description: "API Gateway endpoint URL for MCP server"
    Value: !Sub "https://${McpApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/mcp"
  McpSessionsTableName:
    Description: "Name of the DynamoDB table for MCP sessions"
    Value: !Ref McpSessionsTable
  McpRequestHeader:
    Value: !Sub "Authorization : Bearer ${McpAuthToken}"
  VsCode:
    Value: !Sub https://${CloudFrontDistribution.DomainName}