Transform: AWS::LanguageExtensions
Parameters:
  Username:
    Type: String
    Default: kiro
  GitCloneUrl:
    Type: String
    Default: https://github.com/iamhansko/spirit-of-kiro.git
  GitCloneBranch:
    Type: String
    Default: challenge
  InboundFromAnywhere:
    Type: String
    Default: "False"
    AllowedValues: ["True", "False"]
    Description: SecurityGroup Inbound Rule (Source 0.0.0.0/0)
  AmiId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-windows-latest/Windows_Server-2025-Korean-Full-Base
Conditions:
  SecurityGroupInboundFromAnywhere: !Equals [!Ref InboundFromAnywhere, "True"]

Mappings:
  AzMapping: 
    a:
      PublicSubnetCidr: 10.0.0.0/24
      PrivateSubnetCidr: 10.0.1.0/24
    b: 
      PublicSubnetCidr: 10.0.2.0/24
      PrivateSubnetCidr: 10.0.3.0/24
    c: 
      PublicSubnetCidr: 10.0.4.0/24
      PrivateSubnetCidr: 10.0.5.0/24

Resources:
  KeyPair:
    Type: AWS::EC2::KeyPair
    Properties:
      KeyName: !Sub
        - key-${Id}
        - Id: !Select [3, !Split ['-', !Select [2, !Split ['/', !Ref AWS::StackId]]]]
  
  Vpc:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.0.0.0/16
      EnableDnsSupport: True
      EnableDnsHostnames: True
      Tags:
        - Key: Name
          Value: vpc

  # PublicSubnets
  Fn::ForEach::PublicSubnets:
    - Az
    - [a]
    - PublicSubnet${Az}:
        Type: AWS::EC2::Subnet
        Properties:
          AvailabilityZone: !Sub ${AWS::Region}${Az}
          CidrBlock: !FindInMap [AzMapping, !Ref Az, PublicSubnetCidr]
          MapPublicIpOnLaunch: true
          Tags:
            - Key: Name
              Value: !Sub public-subnet-${Az}
          VpcId: !Ref Vpc
      PublicSubnet${Az}RouteTableAssociation:
        Type: AWS::EC2::SubnetRouteTableAssociation
        Properties:
          RouteTableId: !Ref PublicSubnetRouteTable
          SubnetId: 
            Ref: !Sub PublicSubnet${Az}
  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      Tags:
        - Key: Name
          Value: public-rt
      VpcId: !Ref Vpc
  InternetGateway:
    Type: AWS::EC2::InternetGateway
    Properties:
      Tags:
        - Key: Name
          Value: igw
  VpcInternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      InternetGatewayId: !Ref InternetGateway
      VpcId: !Ref Vpc
  PublicSubnetRoute:
    Type: AWS::EC2::Route
    DependsOn:
      - VpcInternetGatewayAttachment
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: !Ref InternetGateway
      RouteTableId: !Ref PublicSubnetRouteTable
  
  WindowsEc2:
    Type: AWS::EC2::Instance
    CreationPolicy:
      ResourceSignal:
        Count: '1'                
        Timeout: PT15M
    Properties:
      ImageId: !Ref AmiId
      InstanceType: m5.2xlarge
      KeyName: !Ref KeyPair
      NetworkInterfaces: 
        - AssociatePublicIpAddress: True
          DeviceIndex: 0
          SubnetId: !Ref PublicSubneta
          GroupSet: 
            - !Ref WindowsEc2SecurityGroup
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeType: gp3
            VolumeSize: 100
            DeleteOnTermination: true
            Encrypted: false
      Tags: 
        - Key: Name
          Value: windows
      IamInstanceProfile: !Ref WindowsEc2InstanceProfile
      UserData: 
        # C:\Windows\System32\config\systemprofile\AppData\Local\Temp
        Fn::Base64: !Sub |
          <powershell>
          # Kiro Workshop Windows Setup - Simplified
          $ErrorActionPreference = "Continue"
          $ProgressPreference = 'SilentlyContinue'
          $LogFile = "C:\ProgramData\KiroWorkshop\setup.log"
          New-Item -ItemType Directory -Path "C:\ProgramData\KiroWorkshop" -Force

          function Write-Log {
              param([string]$Message)
              $Timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
              $LogMessage = "[$Timestamp] $Message"
              Write-Host $LogMessage
              Add-Content -Path $LogFile -Value $LogMessage -ErrorAction SilentlyContinue
          }

          Write-Log "Starting Kiro Workshop Windows Setup"

          try {
              # Get region and password
              $Token = Invoke-RestMethod -Uri "http://169.254.169.254/latest/api/token" -Method PUT -Headers @{"X-aws-ec2-metadata-token-ttl-seconds" = "21600"} -TimeoutSec 30
              $Region = Invoke-RestMethod -Uri "http://169.254.169.254/latest/meta-data/placement/region" -Headers @{"X-aws-ec2-metadata-token" = $Token} -TimeoutSec 30
              Write-Log "Region: $Region"

              # Install AWS PowerShell module
              Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.201 -Force -Scope AllUsers
              Install-Module -Name AWS.Tools.SecretsManager -Force -AllowClobber -Scope AllUsers
              Import-Module AWS.Tools.SecretsManager -Force
              Set-DefaultAWSRegion -Region $Region

              $SecretValue = Get-SECSecretValue -SecretId ${WindowsUserPassword.Id} -Region $Region
              $WorkshopPassword = ($SecretValue.SecretString | ConvertFrom-Json).password
              Write-Log "Password retrieved"

              # Enable RDP - Minimal configuration
              Write-Log "Configuring RDP..."
              Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0 -Force
              Set-Service -Name "TermService" -StartupType Automatic
              Start-Service -Name "TermService" -ErrorAction SilentlyContinue
              netsh advfirewall firewall set rule group="Remote Desktop" new enable=yes

              # Create workshop user
              Write-Log "Creating workshop user..."
              Remove-LocalUser -Name "${Username}" -ErrorAction SilentlyContinue
              $Password = ConvertTo-SecureString $WorkshopPassword -AsPlainText -Force
              $User = New-LocalUser -Name "${Username}" -Password $Password -FullName "Workshop User" -PasswordNeverExpires -AccountNeverExpires
              Add-LocalGroupMember -Group "Administrators" -Member "${Username}" -ErrorAction SilentlyContinue
              Add-LocalGroupMember -Group "Remote Desktop Users" -Member "${Username}" -ErrorAction SilentlyContinue

              # Setup directories - Enhanced domain handling
              Write-Log "Finding workshop user profile..."
              $UserProfiles = Get-WmiObject -Class Win32_UserProfile | Where-Object {
                  $_.LocalPath -like "*${Username}*" -and
                  $_.LocalPath -notlike "*.bak" -and
                  $_.LocalPath -notlike "*temp*"
              }

              if ($UserProfiles) {
                  # Find workshop.ComputerName pattern specifically
                  $ComputerName = $env:COMPUTERNAME
                  $PreferredPattern = "${Username}.$ComputerName"

                  $PreferredProfile = $UserProfiles | Where-Object {$_.LocalPath -like "*$PreferredPattern*" -and $_.LocalPath -notlike "*.000" -and $_.LocalPath -notlike "*.001"}

                  if ($PreferredProfile) {
                      $UserProfilePath = $PreferredProfile[0].LocalPath
                      Write-Log "Selected preferred profile: $UserProfilePath"
                  } else {
                      # Fallback to shortest path
                      $UserProfilePath = ($UserProfiles.LocalPath | Sort-Object Length)[0]
                      Write-Log "Selected fallback profile: $UserProfilePath"
                  }

                  # Log all found profiles for debugging
                  foreach ($profile in $UserProfiles) {
                      Write-Log "Found ${Username} profile: $($profile.LocalPath)"
                  }
              } else {
                  # Deterministically construct workshop.ComputerName path
                  $ComputerName = $env:COMPUTERNAME
                  $UserProfilePath = "C:\Users\${Username}.$ComputerName"
                  Write-Log "Using constructed path: $UserProfilePath"
              }

              $WorkshopDir = "C:\ProgramData\KiroWorkshop"
              $TempDir = "$WorkshopDir\temp"
              New-Item -ItemType Directory -Path $TempDir -Force

              # Install Chocolatey FIRST
              Write-Log "Installing Chocolatey..."
              Set-ExecutionPolicy Bypass -Scope Process -Force
              [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
              iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))

              # Install development tools via Chocolatey
              Write-Log "Installing Git..."
              choco install git -y

              Write-Log "Installing AWS CLI..."
              choco install awscli -y

              Write-Log "Installing Node.js..."
              choco install nodejs-lts --version="22.19.0" -y

              Write-Log "Installing Python 3.13"
              choco install python313 -y

              # Refresh environment variables after installations
              $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")

              python --version
              Set-Location $TempDir
              python -m venv .venv
              .\.venv\Scripts\activate
              python -m pip install boto3 requests requests_aws4auth
              echo "import json
              import os
              import boto3
              import requests
              from requests_aws4auth import AWS4Auth
              if __name__ == '__main__':
                session = boto3.Session()
                credentials = session.get_credentials()
                result = {
                  "access_key": credentials.access_key,
                  "secret_key": credentials.secret_key,
                  "token": credentials.token
                }
                print(json.dumps(result))" > init.py
              # $PYTHON_RESULT = python init.py | ConvertFrom-Json
              deactivate

              # Clone project AFTER Git is installed
              Write-Log "Cloning Spirit of Kiro project..."
              $GitUrl = "${GitCloneUrl}"
              $GitBranch = "${GitCloneBranch}"
              Write-Log "Git URL: $GitUrl, Branch: $GitBranch"

              # Wait for git to be available in PATH
              $maxRetries = 10
              $retryCount = 0
              do {
                  Start-Sleep -Seconds 3
                  $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
                  $gitAvailable = Get-Command git -ErrorAction SilentlyContinue
                  $retryCount++
              } while (-not $gitAvailable -and $retryCount -lt $maxRetries)

              if ($gitAvailable) {
                  Set-Location $WorkshopDir
                  git clone --branch $GitBranch $GitUrl $GitBranch
                  Write-Log "Git clone completed"

                  # Navigate to cloned project directory and run setup commands
                  Set-Location "$WorkshopDir\$GitBranch"
                  Write-Log "Running project setup commands..."

                  # Install Bun and run npm commands
                  irm bun.sh/install.ps1 | iex
                  $env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
                  
                  Write-Log "Project setup completed"
                  Set-Location "$WorkshopDir\${GitCloneBranch}\server"
                  npm cache clean --force
                  bun install
                  Set-Location "$WorkshopDir\${GitCloneBranch}\client"
                  npm cache clean --force
                  bun install

                  @'
          Set-Location C:\ProgramData\KiroWorkshop\${GitCloneBranch}\server
          $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          if (-not (Get-Command bun -ErrorAction SilentlyContinue)) {
            irm bun.sh/install.ps1 | iex
            $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          }
          npm cache clean --force
          bun install
          $Env:AWS_REGION="${AWS::Region}"
          $Env:COGNITO_USER_POOL_ID="${UserPool}"
          $Env:COGNITO_CLIENT_ID="${UserPoolClient}"
          $Env:COGNITO_USER_POOL_ARN="${UserPool.Arn}"
          $Env:ITEM_IMAGES_SERVICE_URL="https://d16sw0kh78rbrs.cloudfront.net"
          $Env:DYNAMODB_TABLE_ITEMS="${ItemsTable}"
          $Env:DYNAMODB_TABLE_INVENTORY="${InventoryTable}"
          $Env:DYNAMODB_TABLE_LOCATION="${LocationTable}"
          $Env:DYNAMODB_TABLE_USERS="${UsersTable}"
          $Env:DYNAMODB_TABLE_USERNAMES="${UsernamesTable}"
          $Env:DYNAMODB_TABLE_PERSONA="${PersonaTable}"
          bun --watch server.ts
          '@ | Out-File -FilePath "C:\ProgramData\KiroWorkshop\temp\server.ps1"

                  @'
          Set-Location C:\ProgramData\KiroWorkshop\${GitCloneBranch}\client
          if (-not (Get-Command bun -ErrorAction SilentlyContinue)) {
            irm bun.sh/install.ps1 | iex
            $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          }
          $Env:Path = [System.Environment]::GetEnvironmentVariable("Path","Machine") + ";" + [System.Environment]::GetEnvironmentVariable("Path","User")
          npm cache clean --force
          bun install
          $Env:VITE_WS_URL="http://localhost:8080/"
          bun run dev
          '@ | Out-File -FilePath "C:\ProgramData\KiroWorkshop\temp\client.ps1"
              } else {
                  Write-Log "Git not available, skipping clone"
              }

              # Verify installations
              Write-Log "Verifying installations..."
              try {
                  $gitVersion = git --version
                  Write-Log "Git installed: $gitVersion"
              } catch {
                  Write-Log "Git verification failed"
              }

              try {
                  $awsVersion = aws --version
                  Write-Log "AWS CLI installed: $awsVersion"
              } catch {
                  Write-Log "AWS CLI verification failed"
              }

              try {
                  $nodeVersion = node --version
                  Write-Log "Node.js installed: $nodeVersion"
              } catch {
                  Write-Log "Node.js verification failed"
              }

              # Set permissions
              icacls $WorkshopDir /grant "${Username}:F" /T /Q
              if (Test-Path $UserProfilePath) {
                  icacls "$UserProfilePath" /grant "${Username}:F" /T /Q
              }

              # Create logon script for workshop user (runs after first login)
              Write-Log "Creating workshop user logon script..."
              $LogonScript = '# Workshop User First Logon Setup' + "`n"
              $LogonScript += '$LogFile = "C:\ProgramData\KiroWorkshop\logon.log"' + "`n"
              $LogonScript += 'function Write-LogonLog { param([string]$Message); Add-Content -Path $LogFile -Value "[$((Get-Date))] $Message" }' + "`n"
              $LogonScript += 'Write-LogonLog "Workshop user first logon setup started"' + "`n"
              $LogonScript += '$DesktopPath = [Environment]::GetFolderPath("Desktop")' + "`n"
              $LogonScript += 'Write-LogonLog "Desktop path: $DesktopPath"' + "`n"
              $LogonScript += '$WshShell = New-Object -comObject WScript.Shell' + "`n"
              $LogonScript += 'if (Test-Path "C:\ProgramData\Kiro\Kiro.exe") {' + "`n"
              $LogonScript += '    $KiroShortcut = $WshShell.CreateShortcut("$DesktopPath\Kiro IDE.lnk")' + "`n"
              $LogonScript += '    $KiroShortcut.TargetPath = "C:\ProgramData\Kiro\Kiro.exe"' + "`n"
              $LogonScript += '    $KiroShortcut.WorkingDirectory = "C:\ProgramData\Kiro"' + "`n"
              $LogonScript += '    $KiroShortcut.Save()' + "`n"
              $LogonScript += '    Write-LogonLog "Kiro IDE shortcut created"' + "`n"
              $LogonScript += '}' + "`n"
              $LogonScript += 'if (Test-Path "C:\ProgramData\KiroWorkshop\${GitCloneBranch}") {' + "`n"
              $LogonScript += '    $ProjectShortcut = $WshShell.CreateShortcut("$DesktopPath\Workshop Project.lnk")' + "`n"
              $LogonScript += '    $ProjectShortcut.TargetPath = "C:\ProgramData\KiroWorkshop\${GitCloneBranch}"' + "`n"
              $LogonScript += '    $ProjectShortcut.Save()' + "`n"
              $LogonScript += '    Write-LogonLog "Project shortcut created"' + "`n"
              $LogonScript += '}' + "`n"
              $LogonScript += 'if (Test-Path "C:\ProgramData\KiroWorkshop\temp\server.ps1") {' + "`n"
              $LogonScript += '    $ServerShortcut = $WshShell.CreateShortcut("$DesktopPath\01 GameServer.lnk")' + "`n"
              $LogonScript += '    $ServerShortcut.TargetPath = "powershell.exe"' + "`n"
              $LogonScript += '    $ServerShortcut.Arguments = "-ExecutionPolicy Bypass -NoExit -File C:\ProgramData\KiroWorkshop\temp\server.ps1"' + "`n"
              $LogonScript += '    $ServerShortcut.Save()' + "`n"
              $LogonScript += '    $ServerShortcutBytes = [System.IO.File]::ReadAllBytes("$DesktopPath\01 GameServer.lnk")' + "`n"
              $LogonScript += '    $ServerShortcutBytes[0x15] = $ServerShortcutBytes[0x15] -bor 0x20' + "`n"
              $LogonScript += '    [System.IO.File]::WriteAllBytes("$DesktopPath\01 GameServer.lnk", $ServerShortcutBytes)' + "`n"
              $LogonScript += '    Write-LogonLog "Game Server shortcut created"' + "`n"
              $LogonScript += '}' + "`n"
              $LogonScript += 'if (Test-Path "C:\ProgramData\KiroWorkshop\temp\client.ps1") {' + "`n"
              $LogonScript += '    $ClientShortcut = $WshShell.CreateShortcut("$DesktopPath\02 GameClient.lnk")' + "`n"
              $LogonScript += '    $ClientShortcut.TargetPath = "powershell.exe"' + "`n"
              $LogonScript += '    $ClientShortcut.Arguments = "-ExecutionPolicy Bypass -NoExit -File C:\ProgramData\KiroWorkshop\temp\client.ps1"' + "`n"
              $LogonScript += '    $ClientShortcut.Save()' + "`n"
              $LogonScript += '    $ClientShortcutBytes = [System.IO.File]::ReadAllBytes("$DesktopPath\02 GameClient.lnk")' + "`n"
              $LogonScript += '    $ClientShortcutBytes[0x15] = $ClientShortcutBytes[0x15] -bor 0x20' + "`n"
              $LogonScript += '    [System.IO.File]::WriteAllBytes("$DesktopPath\02 GameClient.lnk", $ClientShortcutBytes)' + "`n"
              $LogonScript += '    Write-LogonLog "Game Client shortcut created"' + "`n"
              $LogonScript += '}' + "`n"
              $LogonScript += 'Write-LogonLog "Workshop user setup completed"' + "`n"
              $LogonScript += 'Remove-Item $MyInvocation.MyCommand.Path -Force' + "`n"

              $LogonScriptPath = "C:\ProgramData\KiroWorkshop\${Username}-setup.ps1"
              Set-Content -Path $LogonScriptPath -Value $LogonScript

              # Set logon script in registry for workshop user
              $LogonKey = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
              Set-ItemProperty -Path $LogonKey -Name "WorkshopSetup" -Value "powershell.exe -ExecutionPolicy Bypass -File `"$LogonScriptPath`"" -Force

              # Install Kiro IDE - Minimal approach
              Write-Log "Installing Kiro IDE..."
              $KiroUrl = "https://prod.download.desktop.kiro.dev/releases/stable/win32-x64/signed/0.7.45/kiro-ide-0.7.45-stable-win32-x64.exe"
              $KiroInstaller = "$TempDir\kiro-installer.exe"
              Invoke-WebRequest -Uri $KiroUrl -OutFile $KiroInstaller -TimeoutSec 300
              $proc = Start-Process $KiroInstaller -ArgumentList "/VERYSILENT", "/NORESTART" -PassThru
              Wait-Process -Id $proc.Id
              Get-Process | Where-Object {$_.ParentProcessId -eq $proc.Id} | Stop-Process -Force -ErrorAction SilentlyContinue

              # Move Kiro from Administrator AppData to ProgramData
              Write-Log "Configuring Kiro IDE for workshop user..."
              $KiroInstallDir = "C:\Users\Administrator\AppData\Local\Programs\Kiro"
              $ProgramDataKiroPath = "C:\ProgramData\Kiro"
              if (Test-Path $KiroInstallDir) {
                  robocopy "$KiroInstallDir" "$ProgramDataKiroPath" /E /R:1 /W:1 /NP
                  icacls "$ProgramDataKiroPath" /grant "${Username}:F" /T /Q
              }
          } catch {
              Write-Log "Setup failed: $($_.Exception.Message)"
              cfn-signal --success false --stack ${AWS::StackName} --resource WindowsEc2 --region ${AWS::Region}
              throw
          }

          cfn-signal --success true --stack ${AWS::StackName} --resource WindowsEc2 --region ${AWS::Region}
          shutdown /r /t 5 /c "Kiro Workshop setup completed"
          </powershell>
  WindowsEc2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security Group
      GroupName: windows-sg
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        !If [SecurityGroupInboundFromAnywhere, [{
          "IpProtocol": "tcp",
          "FromPort": 3389,
          "ToPort": 3389,
          "CidrIp": "0.0.0.0/0"
        }], []]
      Tags:
        - Key: Name
          Value: windows-sg
  WindowsEc2IamRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AdministratorAccess
  WindowsEc2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles: 
        - !Ref WindowsEc2IamRole

  WindowsUserPassword:
    Type: AWS::SecretsManager::Secret
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      GenerateSecretString:
        SecretStringTemplate: !Sub '{"username": "${Username}"}'
        GenerateStringKey: password
        PasswordLength: 20
        ExcludeCharacters: '"@/\'
        RequireEachIncludedType: true
        IncludeSpace: false
  SecretPlaintext:
    Type: Custom::SecretPlaintextLambda
    Properties:
      ServiceToken: !GetAtt SecretPlaintextLambda.Arn
      ServiceTimeout: 15
      SecretArn: !Ref WindowsUserPassword
  SecretPlaintextLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: !Sub lambda.${AWS::URLSuffix}
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: SecretsManagerPolicy
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - secretsmanager:GetSecretValue
                Resource: "*"
  SecretPlaintextLambda:
    Type: AWS::Lambda::Function
    Properties:
      Description: Return the value of the secret
      Handler: index.lambda_handler
      Runtime: python3.13
      MemorySize: 128
      Timeout: 10
      Architectures:
        - arm64
      Role: !GetAtt SecretPlaintextLambdaRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def is_valid_json(json_string):
            logger.debug(f'Calling is_valid_json: {json_string}')
            try:
              json.loads(json_string)
              logger.info('Secret is in json format')
              return True
            except json.JSONDecodeError:
              logger.info('Secret is in string format')
              return False

          def lambda_handler(event, context):
            logger.debug(f'event: {event}')
            logger.debug(f'context: {context}')
            try:
              if event['RequestType'] == 'Delete':
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData={}, reason='No action to take')
              else:
                resource_properties = event['ResourceProperties']
                secret_name = resource_properties['SecretArn']
                secrets_mgr = boto3.client('secretsmanager')
                logger.info(f'Getting secret from {secret_name}')
                secret = secrets_mgr.get_secret_value(SecretId=secret_name)
                logger.debug(f'secret: {secret}')
                secret_value = secret['SecretString']

                responseData = {}
                if is_valid_json(secret_value):
                    secret_json = json.loads(secret_value)
                    responseData = secret_json
                else:
                    responseData = {'secret': secret_value}

                logger.debug(f'responseData: {responseData}')
                logger.debug(f'type(responseData): {type(responseData)}')
                cfnresponse.send(event, context, cfnresponse.SUCCESS, responseData=responseData, reason='OK', noEcho=True)
            except Exception as e:
              logger.error(e)
              cfnresponse.send(event, context, cfnresponse.FAILED, responseData={}, reason=str(e))

  UserPool:
    Type: AWS::Cognito::UserPool
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      UserPoolName: !Sub "${AWS::StackName}-user-pool"
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: false
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: true
          RequireUppercase: true
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: preferred_username
          AttributeDataType: String
          Required: true
          Mutable: true
      UsernameAttributes:
        - email
      UsernameConfiguration:
        CaseSensitive: false
      UserPoolAddOns:
        AdvancedSecurityMode: "OFF"
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: !Sub "${AWS::StackName}-client"
      GenerateSecret: false
      PreventUserExistenceErrors: ENABLED
      ExplicitAuthFlows:
        - USER_PASSWORD_AUTH
      AccessTokenValidity: 1
      IdTokenValidity: 1
      RefreshTokenValidity: 30
      TokenValidityUnits:
        AccessToken: hours
        IdToken: hours
        RefreshToken: days
  
  ItemsTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
  InventoryTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: id
          AttributeType: S
        - AttributeName: itemId
          AttributeType: S
      KeySchema:
        - AttributeName: id
          KeyType: HASH
        - AttributeName: itemId
          KeyType: RANGE
  LocationTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: itemId
          AttributeType: S
        - AttributeName: location
          AttributeType: S
      KeySchema:
        - AttributeName: itemId
          KeyType: HASH
        - AttributeName: location
          KeyType: RANGE
  UsersTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
  UsernamesTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: username
          AttributeType: S
      KeySchema:
        - AttributeName: username
          KeyType: HASH
  PersonaTable:
    Type: AWS::DynamoDB::Table
    DeletionPolicy: Delete
    UpdateReplacePolicy: Delete
    Properties:
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      AttributeDefinitions:
        - AttributeName: userId
          AttributeType: S
        - AttributeName: detail
          AttributeType: S
      KeySchema:
        - AttributeName: userId
          KeyType: HASH
        - AttributeName: detail
          KeyType: RANGE

Outputs:
  01RdpUrl:
    Value: !Sub ${WindowsEc2.PublicIp}:3389
  02Username:
    Value: !Ref Username
  03Password:
    Value: !GetAtt SecretPlaintext.password